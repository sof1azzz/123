第五章概括笔记：同步访问共享对象

5.1 面临的挑战

在多线程程序中，共享数据结构可能被多个线程同时访问，若不加控制，会出现竞态条件（Race Conditions）。
这一节通过“太多牛奶”问题引出竞态问题：两个线程尝试往冰箱加牛奶，但因检查和加牛奶之间没有同步，
可能导致重复购买。

解决方案：

引入原子性（Atomicity）概念：一组操作要么全部完成，要么都不执行。

逐步提出更合理的解决方案，例如使用标志位或者锁的机制来实现同步。

引导读者思考在不可靠顺序下如何设计正确的并发程序。

5.2 共享对象的结构设计

本节提出设计线程安全的共享对象的关键原则。设计应保证：

所有共享数据通过共享对象封装，其他线程只能通过方法访问；

对象的状态变化保持一致性，不暴露中间状态；

使用同步机制（如锁）控制并发访问，避免破坏内部不变式（invariant）。

作者建议采用面向对象的封装方式，并在方法中加入必要的同步操作，避免在外部进行同步逻辑。

5.3 锁（Locks）：互斥访问

锁是最基本的同步工具，用于确保临界区（critical section）内的代码在任何时刻只被一个线程执行。
锁的API包括：

lock()

unlock()

使用锁的正确姿势：

尽量缩小临界区范围，提高并发度；

避免死锁，比如始终以固定顺序申请多个锁；

不要在持有锁的情况下执行可能阻塞的操作。

案例：线程安全的有界队列

使用一个锁保护整个队列结构。

入队（enqueue）和出队（dequeue）操作必须互斥执行。

高并发下，使用更精细的锁（如读写锁）可以提升性能。

5.4 条件变量（Condition Variables）：等待条件变化

锁提供互斥，但不能解决条件同步问题：线程需要等待某个条件成立才能继续。

条件变量允许线程在某个条件不满足时进入等待状态，并在条件满足时被唤醒。

常见方法包括：

wait()：当前线程释放锁并等待；

signal()：唤醒一个等待线程；

broadcast()：唤醒所有等待线程。

案例：阻塞式有界队列

如果队列为空，消费者线程 wait()；

如果队列已满，生产者线程 wait()；

每次状态变化后使用 signal() 唤醒对应线程。

5.5 共享对象的设计与实现

本节整合前面内容，提出共享对象设计的模式：

明确对象的不变式；

使用锁保护不变式；

利用条件变量实现线程间协作；

避免使用线程不安全的操作，如 printf、malloc 等。

建议先写出不含同步的单线程版本，再逐步引入同步机制，并通过测试验证其正确性。

5.6 三个案例研究

读者-写者锁（Readers/Writers Lock）

允许多个读线程并发访问，但写线程需独占；

分为读优先、写优先、无偏差三种策略；

使用两个计数器记录当前读者/等待写者数量。

同步屏障（Synchronization Barriers）

所有线程到达屏障点后才能继续执行下一阶段；

应用场景如并行计算中每一轮同步；

使用计数器和条件变量实现。

FIFO 阻塞有界队列

结合锁和条件变量实现线程安全队列；

保证队列先进先出，同时支持多个线程并发访问。

5.7 同步对象的实现

讲解如何在更底层实现同步机制。

单处理器系统：

通过关闭中断（disable/enable interrupts）实现原子操作；

不适用于多处理器系统。

多处理器系统：

使用原子硬件指令如 test-and-set、compare-and-swap 实现自旋锁（spinlock）；

实现公平队列锁（如Ticket Lock）防止饥饿；

可实现递归锁、读写锁、互斥锁等。

Linux 2.6 内核中的锁机制：

采用轻量级锁结构体 spinlock_t；

在内核中大量使用自旋锁保障并发访问安全。

本章通过实际案例与实现方式相结合，全面介绍了多线程并发编程中同步机制的核心原理与实践方法。