
==============================
 Chapter 2 - OS Kernel Details
==============================

----------------------------------------
2.1 The Process Abstraction
----------------------------------------

ğŸ”¹ PCB (Process Control Block)
The PCB stores all the information the operating system needs about a particular process:
- Where it is stored in memory
- Where its executable image resides on disk
- Which user asked it to execute
- What privileges the process has

----------------------------------------
2.2 Dual-Mode Operation
----------------------------------------

ğŸ”¹ User Mode vs. Kernel Mode
- In user mode, protection checks are enforced by the CPU.
- In kernel mode, the OS executes with full privileges.

ğŸ”¹ Required Hardware Support
1. Privileged Instructions
2. Memory Protection
3. Timer Interrupts
4. Safe transition between modes

----------------------------------------
2.3 Types of Mode Transfer
----------------------------------------

ğŸ”¹ User â†’ Kernel
- Interrupts: Asynchronous hardware signals
- Processor Exception: Errors like divide-by-zero
- System Calls: Interface to kernel services

ğŸ”¹ Kernel â†’ User
- Start/resume/switch process, upcalls

----------------------------------------
2.4 Implementing Safe Mode Transfer
----------------------------------------

1. Interrupt Vector Table
2. Interrupt Stack
3. Two Stacks per Process
4. Interrupt Masking
5. Saving/Restoring Registers

----------------------------------------
2.5 x86 Mode Transfer (Trapframe)
----------------------------------------

Steps:
1. Mask interrupts
2. Save SS, ESP, EFLAGS, CS, EIP to temp regs
3. Switch to kernel stack
4. Push saved values onto kernel stack
5. Push error code (if any)
6. Jump to interrupt handler

ğŸ“¦ x86 Trapframe (Top to Bottom of Kernel Stack):
--------------------------------------------------
- General Registers (via pushad):
  EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP
- Error Code or Dummy
- EIP
- CS
- EFLAGS
- ESP (user)
- SS (user)

ğŸ§  Register Usage Summary:

| Register | Name                | Purpose                                      |
|----------|---------------------|----------------------------------------------|
| EIP      | Instruction Pointer | Next instruction to execute                  |
| CS       | Code Segment        | Segment selector for EIP                    |
| EFLAGS   | Flags Register      | Status and control flags                     |
| ESP      | Stack Pointer       | User stack pointer for context restoration   |
| SS       | Stack Segment       | Selector for ESP                             |
| EAX      | Accumulator         | Return value, arithmetic                     |
| EBX      | Base                | Addressing, temporary data                   |
| ECX      | Counter             | Loop counts, shift operations                |
| EDX      | Data                | I/O, arithmetic                              |
| ESI      | Source Index        | String/memory source                         |
| EDI      | Destination Index   | String/memory destination                    |
| EBP      | Base Pointer        | Stack frame for function                     |
| ESP      | Stack Pointer       | Stack top                                    |

----------------------------------------
2.6 Implementing Secure System Calls
----------------------------------------

When crossing user â†” kernel boundary, kernel must assume inputs may be malicious.

ğŸ›¡ï¸ Kernel Stub Responsibilities:
1. Locate system call arguments
2. Validate parameters (e.g., bounds, permissions)
3. Copy args to kernel memory BEFORE checking (prevent TOCTOU)
4. Copy results back to user space safely

ğŸ” Example Flow:

User Program
    â†“
User Stub
    â†“  (int #TrapCode)
â†’ Trap Handler (in Kernel)
    â†“
Validate + Copy Args (Kernel Stub)
    â†“
Kernel Operation (e.g., open)
    â†“
Return Result
    â†“
User Stub â† %eax
    â†“
User Program resumes

ğŸ”§ Kernel Stub Code Example (open):
int KernelStub_Open() {
    char *localCopy[MaxSize + 1];
    
    if (!validUserAddressRange(...)) return error;
    
    filename = VirtualToKernel(userStackPointer);
    
    if (!VirtualToKernelStringCopy(filename, localCopy, MaxSize)) return error;
    
    localCopy[MaxSize] = 0;
    
    if (!UserFileAccessPermitted(...)) return error;
    
    return Kernel_Open(localCopy);
}

----------------------------------------
2.7 Starting a New Process
----------------------------------------

The kernel must:

1. Allocate and initialize the process control block.

2. Allocate memory for the process.
 
3. Copy the program from disk into the newly allocated memory.

4. Allocate a user-level stack for user-level execution.

5. Allocate a kernel-level stack for handling system calls, interrupts and processor exceptions.

To start running the program, the kernel must also:

1. Copy arguments into user memory.

2. Transfer control to user mode. 

The compiler inserts one level of indirection. It puts a "stub" at the location in the processâ€™s
memory where the kernel will jump when the process starts. The stubâ€™s job is to call main
and then, if main returns, to call exit â€” the system call to terminate the process. Without
the stub, a user program that returned from main would try to pop the return program
counter, and since there is no such address on the stack, the processor would start
executing random code.
    start(arg1, arg2) { 
        main(arg1, arg2);   // Call program main. 
        exit();             // If main returns, call exit. 
    }

----------------------------------------
2.8 Implementing Upcalls
----------------------------------------

----------------------------------------
2.9 Case Study: Booting an Operating System Kernel
----------------------------------------

----------------------------------------
2.10 Case Study: Virtual Machines
----------------------------------------

Exercises

1. When a user process is interrupted or causes a processor exception, the x86
 hardware switches the stack pointer to a kernel stack, before saving the current
 process state. Explain why.

x86 ç¡¬ä»¶åœ¨ä¸­æ–­æˆ–å¼‚å¸¸æ—¶åˆ‡æ¢åˆ°å†…æ ¸æ ˆçš„åŸå› ï¼š
ä¸»è¦åŸå› ï¼šå®‰å…¨æ€§å’Œå¯é æ€§ã€‚
ç”¨æˆ·æ ˆä¸å¯ä¿¡ï¼š ç”¨æˆ·è¿›ç¨‹çš„æ ˆå¯èƒ½å·²ç»è¢«ç ´åï¼ˆä¾‹å¦‚ï¼Œç¼“å†²åŒºæº¢å‡ºæ”»å‡»ï¼‰ã€æŒ‡å‘æ— æ•ˆå†…å­˜åœ°å€ï¼Œæˆ–è€…æ ¹æœ¬æ²¡æœ‰è¶³å¤Ÿçš„ç©ºé—´ï¼ˆæ ˆæº¢å‡ºï¼‰ã€‚å¦‚æœå†…æ ¸è¯•å›¾åœ¨ç”¨æˆ·æ ˆä¸Šä¿å­˜çŠ¶æ€æˆ–æ‰§è¡Œå¤„ç†ç¨‹åºï¼Œå¯èƒ½ä¼šå› ä¸ºæ ˆæœ¬èº«çš„é—®é¢˜è€Œå´©æºƒã€‚
å†…æ ¸éš”ç¦»ï¼š å†…æ ¸éœ€è¦åœ¨å…¶è‡ªèº«å—ä¿æŠ¤çš„åœ°å€ç©ºé—´ä¸­è¿è¡Œï¼Œä½¿ç”¨ä¸€ä¸ªç‹¬ç«‹ã€å¯é ã€å¤§å°å·²çŸ¥çš„æ ˆã€‚è¿™ç¡®ä¿äº†ä¸­æ–­æˆ–å¼‚å¸¸å¤„ç†ç¨‹åºæœ‰ä¸€ä¸ªå¹²å‡€ã€å®‰å…¨çš„ç¯å¢ƒæ¥æ‰§è¡Œï¼Œä¸ä¼šå—åˆ°ç”¨æˆ·è¿›ç¨‹çŠ¶æ€çš„å½±å“ã€‚
è¿‡ç¨‹ï¼š å½“ä¸­æ–­æˆ–å¼‚å¸¸å‘ç”Ÿæ—¶ï¼Œç¡¬ä»¶ä¼šè‡ªåŠ¨æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼ˆç®€åŒ–ï¼‰ï¼š
æŸ¥è¯¢ä¸­æ–­æè¿°ç¬¦è¡¨ (IDT) è·å–å¤„ç†ç¨‹åºçš„åœ°å€å’Œç›®æ ‡ä»£ç æ®µé€‰æ‹©å­ã€‚
ç›®æ ‡ä»£ç æ®µé€‰æ‹©å­æŒ‡å®šäº†å†…æ ¸ä»£ç æ®µï¼Œå› æ­¤ CPU ç‰¹æƒçº§æå‡åˆ°å†…æ ¸æ€ï¼ˆRing 0ï¼‰ã€‚
ç¡¬ä»¶ä»ä»»åŠ¡çŠ¶æ€æ®µ (TSS) æˆ–ç±»ä¼¼ç»“æ„ä¸­åŠ è½½é¢„è®¾çš„å†…æ ¸æ ˆæŒ‡é’ˆ (SS0:ESP0 æˆ– RSP0)ã€‚
ç¡¬ä»¶å°†ç”¨æˆ·æ€çš„æ ˆæŒ‡é’ˆ (SS:ESP æˆ– RSP)ã€æ ‡å¿—å¯„å­˜å™¨ (EFLAGS æˆ– RFLAGS)ã€ä»£ç æ®µé€‰æ‹©å­ (CS) å’ŒæŒ‡ä»¤æŒ‡é’ˆ (EIP æˆ– RIP) æ¨é€åˆ°æ–°çš„å†…æ ¸æ ˆä¸Šã€‚
è·³è½¬åˆ°ä¸­æ–­/å¼‚å¸¸å¤„ç†ç¨‹åºæ‰§è¡Œã€‚
é€šè¿‡åˆ‡æ¢åˆ°å†…æ ¸æ ˆï¼Œç¡¬ä»¶ä¿è¯äº†å†…æ ¸åœ¨æ¥ç®¡æ§åˆ¶æƒæ—¶ï¼Œæ‹¥æœ‰ä¸€ä¸ªç¨³å®šå¯é çš„æ‰§è¡Œç¯å¢ƒæ¥ä¿å­˜ç”¨æˆ·çŠ¶æ€å¹¶å¤„ç†äº‹ä»¶ã€‚


2. For the â€œHello worldâ€ program, we mentioned that the kernel must copy the string from
 the user program to screen memory. Why must the screenâ€™s buffer memory be
 protected? Explain what might happen if a malicious application could alter any pixel
 on the screen, not just those within its own window.

å±å¹•ç¼“å†²åŒºå†…å­˜ä¿æŠ¤ï¼š
ä¿æŠ¤åŸå› ï¼š
å®Œæ•´æ€§ï¼š é˜²æ­¢ä¸€ä¸ªåº”ç”¨ç¨‹åºæ¶æ„æˆ–æ„å¤–åœ°è¦†ç›–å…¶ä»–åº”ç”¨ç¨‹åºçš„çª—å£å†…å®¹ã€ç³»ç»Ÿ UI å…ƒç´ ï¼ˆå¦‚ä»»åŠ¡æ ã€èœå•ã€å¯¹è¯æ¡†ï¼‰æˆ–æ¡Œé¢èƒŒæ™¯ã€‚è¿™ç»´æŠ¤äº†ç”¨æˆ·ç•Œé¢çš„ç¨³å®šæ€§å’Œå¯é¢„æµ‹æ€§ã€‚
å®‰å…¨æ€§ï¼š é˜²æ­¢æ¶æ„åº”ç”¨ç¨‹åºè¿›è¡Œ UI æ¬ºéª—ã€‚ä¾‹å¦‚ï¼š
ç»˜åˆ¶å‡çš„ç™»å½•æ¡†è¦†ç›–åœ¨åˆæ³•åº”ç”¨çš„çª—å£ä¸Šï¼Œçªƒå–ç”¨æˆ·å¯†ç ã€‚
è¦†ç›–ç³»ç»Ÿå®‰å…¨è­¦å‘Šæˆ–æƒé™è¯·æ±‚å¯¹è¯æ¡†ï¼Œè¯±éª—ç”¨æˆ·æ‰§è¡Œå±é™©æ“ä½œã€‚
éšè—æˆ–ä¼ªé€ å…³é”®ä¿¡æ¯ã€‚
éš”ç¦»æ€§ï¼š ä¿è¯æ¯ä¸ªåº”ç”¨ç¨‹åºåªèƒ½åœ¨å…¶åˆ†é…çš„çª—å£åŒºåŸŸå†…ç»˜åˆ¶ï¼Œè¿™æ˜¯å›¾å½¢åŒ–æ“ä½œç³»ç»Ÿçª—å£ç®¡ç†çš„åŸºç¡€ã€‚
æ— ä¿æŠ¤çš„åæœï¼š
UI æ··ä¹±å’Œç³»ç»Ÿä¸ç¨³å®šï¼š åº”ç”¨ç¨‹åºå¯ä»¥éšæ„æ¶‚æŠ¹å±å¹•ï¼Œå¯¼è‡´ç•Œé¢æ··ä¹±ä¸å ªï¼Œç”¨æˆ·æ— æ³•æ­£å¸¸ä½¿ç”¨ã€‚å…³é”®çš„ç³»ç»Ÿä¿¡æ¯å¯èƒ½è¢«è¦†ç›–ã€‚
UI æ¬ºéª—å’Œé’“é±¼ï¼š æ¶æ„è½¯ä»¶å¯ä»¥è½»æ¾ä¼ªé€ ä»»ä½•åº”ç”¨ç¨‹åºæˆ–ç³»ç»Ÿå¯¹è¯æ¡†çš„å¤–è§‚ï¼Œè¯±å¯¼ç”¨æˆ·è¾“å…¥æ•æ„Ÿä¿¡æ¯æˆ–æˆæƒæ¶æ„æ“ä½œã€‚
æ‹’ç»æœåŠ¡ï¼š æ¶æ„ç¨‹åºå¯ä»¥é€šè¿‡å¿«é€Ÿã€æ— æ„ä¹‰åœ°å¡«æ»¡æ•´ä¸ªå±å¹•ç¼“å†²åŒºæ¥ä½¿æ˜¾ç¤ºå™¨æ— æ³•ä½¿ç”¨ã€‚
ä¿¡æ¯æ³„éœ²ï¼š ç†è®ºä¸Šï¼Œå¦‚æœèƒ½è¯»å–æ•´ä¸ªå±å¹•ç¼“å†²åŒºï¼Œå¯èƒ½è¯»å–åˆ°å…¶ä»–åº”ç”¨ç¨‹åºçª—å£ä¸­çš„æ•æ„Ÿä¿¡æ¯ï¼ˆå°½ç®¡ç°ä»£ç³»ç»Ÿé€šå¸¸æœ‰æ›´å¼ºçš„éš”ç¦»ï¼Œå†™å…¥ä¿æŠ¤æ˜¯åŸºç¡€ï¼‰ã€‚


3. For each of the three mechanisms that supports dual-mode operation â€” privileged
 instructions, memory protection, and timer interrupts â€” explain what might go wrong
 without that mechanism, assuming the system still had the other two.

ç¼ºå°‘åŒæ¨¡å¼æ“ä½œæœºåˆ¶ä¹‹ä¸€çš„åæœï¼ˆå‡è®¾å…¶ä»–ä¸¤ä¸ªå­˜åœ¨ï¼‰ï¼š
ç¼ºå°‘ç‰¹æƒæŒ‡ä»¤ï¼š
åæœï¼š ç”¨æˆ·ç¨‹åºå°†èƒ½å¤Ÿæ‰§è¡Œæ‰€æœ‰ CPU æŒ‡ä»¤ï¼ŒåŒ…æ‹¬é‚£äº›æ§åˆ¶ç¡¬ä»¶ã€å†…å­˜ç®¡ç†å’Œä¸­æ–­çš„æŒ‡ä»¤ã€‚
å…·ä½“é—®é¢˜ï¼š
ç”¨æˆ·ç¨‹åºå¯ä»¥ç›´æ¥æ‰§è¡Œ I/O æŒ‡ä»¤ï¼Œç»•è¿‡å†…æ ¸çš„å®‰å…¨æ£€æŸ¥å’Œèµ„æºç®¡ç†ï¼Œéšæ„è®¿é—®ç£ç›˜ã€ç½‘ç»œç­‰è®¾å¤‡ã€‚
ç”¨æˆ·ç¨‹åºå¯ä»¥ä¿®æ”¹é¡µè¡¨ï¼Œè®¿é—®å†…æ ¸æˆ–å…¶ä»–è¿›ç¨‹çš„å†…å­˜ï¼ˆå³ä½¿å†…å­˜ä¿æŠ¤æœºåˆ¶å­˜åœ¨ï¼Œä½†ä¿®æ”¹é¡µè¡¨çš„æŒ‡ä»¤ä¸å†å—ä¿æŠ¤ï¼‰ã€‚
ç”¨æˆ·ç¨‹åºå¯ä»¥ç¦ç”¨ä¸­æ–­ï¼Œå¯¼è‡´æ— æ³•å“åº”ç¡¬ä»¶äº‹ä»¶ï¼Œæ— æ³•è¿›è¡Œæ—¶é—´ç‰‡è½®è½¬ï¼ˆå³ä½¿å®šæ—¶å™¨ä¸­æ–­ç¡¬ä»¶å­˜åœ¨ï¼Œä½†ç¦ç”¨ä¸­æ–­çš„æŒ‡ä»¤å¯è¢«ç”¨æˆ·æ‰§è¡Œï¼‰ã€‚
ç”¨æˆ·ç¨‹åºå¯ä»¥æ‰§è¡Œ hlt æŒ‡ä»¤åœæœºã€‚
ç»“æœï¼š ç³»ç»Ÿå®Œå…¨å¤±å»æ§åˆ¶ï¼Œæ²¡æœ‰å®‰å…¨æ€§å’Œç¨³å®šæ€§å¯è¨€ã€‚å†…å­˜ä¿æŠ¤å’Œå®šæ—¶å™¨ä¸­æ–­ä¼šå› ä¸ºç”¨æˆ·ç¨‹åºèƒ½ç›´æ¥ç¦ç”¨æˆ–æ“çºµå®ƒä»¬è€Œå¤±æ•ˆã€‚
ç¼ºå°‘å†…å­˜ä¿æŠ¤ï¼š
åæœï¼š ç”¨æˆ·ç¨‹åºå¯ä»¥è®¿é—®ç‰©ç†å†…å­˜çš„ä»»ä½•ä½ç½®ã€‚
å…·ä½“é—®é¢˜ï¼š
ç”¨æˆ·ç¨‹åºå¯ä»¥è¯»å–æˆ–å†™å…¥å†…æ ¸ä»£ç å’Œæ•°æ®ç»“æ„ï¼Œç ´åå†…æ ¸è¿è¡Œï¼Œæˆ–è€…é€šè¿‡ä¿®æ”¹å†…æ ¸æ•°æ®æå‡è‡ªèº«æƒé™ã€‚
ç”¨æˆ·ç¨‹åºå¯ä»¥è¯»å–æˆ–å†™å…¥å…¶ä»–ç”¨æˆ·è¿›ç¨‹çš„å†…å­˜ç©ºé—´ï¼Œçªƒå–æ•°æ®æˆ–ä½¿å…¶ä»–è¿›ç¨‹å´©æºƒã€‚
å³ä½¿æœ‰ç‰¹æƒæŒ‡ä»¤ï¼Œå†…æ ¸ä¹Ÿæ— æ³•ä¿è¯è‡ªèº«çš„å®Œæ•´æ€§ï¼Œå› ä¸ºç”¨æˆ·ç¨‹åºå¯ä»¥ç›´æ¥ä¿®æ”¹å†…æ ¸å†…å­˜ã€‚
ç»“æœï¼š ç³»ç»Ÿæä¸ç¨³å®šï¼Œæ¯«æ— å®‰å…¨æ€§ã€‚å†…æ ¸å’Œè¿›ç¨‹ä¹‹é—´æ²¡æœ‰éš”ç¦»ã€‚
ç¼ºå°‘å®šæ—¶å™¨ä¸­æ–­ï¼š
åæœï¼š å†…æ ¸æ— æ³•ä¿è¯å‘¨æœŸæ€§åœ°é‡æ–°è·å¾— CPU æ§åˆ¶æƒã€‚
å…·ä½“é—®é¢˜ï¼š
å¦‚æœä¸€ä¸ªç”¨æˆ·ç¨‹åºè¿›å…¥æ— é™å¾ªç¯æˆ–é•¿æ—¶é—´ç­‰å¾…ï¼ˆå¹¶ä¸”ä¸ä¸»åŠ¨æ”¾å¼ƒ CPUï¼‰ï¼Œå®ƒå°†æ°¸ä¹…å ç”¨ CPUã€‚
å†…æ ¸æ— æ³•å®ç°æŠ¢å å¼å¤šä»»åŠ¡å¤„ç†ã€‚ç³»ç»Ÿè¦ä¹ˆå˜æˆåä½œå¼å¤šä»»åŠ¡ï¼ˆä¾èµ–ç¨‹åºè‡ªæ„¿æ”¾å¼ƒ CPUï¼‰ï¼Œè¦ä¹ˆå•ä»»åŠ¡å¡æ­»ã€‚
ä¾èµ–äºæ—¶é—´çš„æœåŠ¡ï¼ˆå¦‚è®°è´¦ã€æ€§èƒ½ç›‘æ§ã€å®šæ—¶ä»»åŠ¡ï¼‰å°†æ— æ³•å‡†ç¡®æ‰§è¡Œã€‚
ç»“æœï¼š ç³»ç»Ÿå“åº”æ€§å·®ï¼Œå…¬å¹³æ€§æ— æ³•ä¿è¯ï¼Œå®¹æ˜“è¢«å•ä¸ªè¡Œä¸ºä¸å½“çš„ç¨‹åºå¡æ­»ã€‚è™½ç„¶æœ‰ç‰¹æƒæŒ‡ä»¤å’Œå†…å­˜ä¿æŠ¤ï¼Œä½†å†…æ ¸å¯èƒ½é•¿æ—¶é—´æ— æ³•è¿è¡Œæ¥æ‰§è¡Œç®¡ç†ä»»åŠ¡ã€‚

 4. Suppose you are tasked with designing the security system for a new web browser
 that supports rendering web pages with embedded web page scripts. What checks
 would you need to implement to ensure that executing buggy or malicious scripts
 could not corrupt or crash the browser?

 5. Define three types of user-mode to kernel-mode transfers.

ç”¨æˆ·æ¨¡å¼åˆ°å†…æ ¸æ¨¡å¼è½¬æ¢çš„ä¸‰ç§ç±»å‹ï¼š
ç³»ç»Ÿè°ƒç”¨ (System Call) / é™·é˜± (Trap)ï¼š ç”¨æˆ·ç¨‹åºä¸»åŠ¨è¯·æ±‚æ“ä½œç³»ç»ŸæœåŠ¡ã€‚è¿™æ˜¯ç¨‹åºè‡ªæ„¿å‘èµ·çš„æ§åˆ¶æƒè½¬ç§»ã€‚ä¾‹å¦‚ï¼Œè¯·æ±‚è¯»æ–‡ä»¶ (read)ã€åˆ›å»ºè¿›ç¨‹ (fork)ã€åˆ†é…å†…å­˜ç­‰ã€‚é€šå¸¸é€šè¿‡ç‰¹å®šçš„ syscallã€sysenter æˆ– int (å¦‚ int 0x80) æŒ‡ä»¤è§¦å‘ã€‚
å¤„ç†å™¨å¼‚å¸¸ (Processor Exception) / æ•…éšœ (Fault) / ä¸­æ­¢ (Abort)ï¼š CPU åœ¨æ‰§è¡Œç”¨æˆ·ç¨‹åºæŒ‡ä»¤æœŸé—´æ£€æµ‹åˆ°é”™è¯¯æˆ–ç‰¹æ®Šæƒ…å†µï¼Œè¢«åŠ¨åœ°å°†æ§åˆ¶æƒäº¤ç»™å†…æ ¸å¤„ç†ã€‚ä¾‹å¦‚ï¼Œé™¤é›¶é”™è¯¯ã€è®¿é—®æ— æ•ˆå†…å­˜åœ°å€ï¼ˆé¡µé”™è¯¯ Page Faultï¼‰ã€æ‰§è¡Œéæ³•æŒ‡ä»¤ã€æ–­ç‚¹æŒ‡ä»¤ (int 3) ç­‰ã€‚
ä¸­æ–­ (Interrupt)ï¼š ç”±å¤–éƒ¨ç¡¬ä»¶è®¾å¤‡å‘å‡ºä¿¡å·ï¼Œè¯·æ±‚ CPU çš„æ³¨æ„ï¼Œå¼‚æ­¥åœ°æ‰“æ–­å½“å‰ç”¨æˆ·ç¨‹åºçš„æ‰§è¡Œï¼Œå°†æ§åˆ¶æƒäº¤ç»™å†…æ ¸ã€‚ä¾‹å¦‚ï¼Œé”®ç›˜è¾“å…¥ã€é¼ æ ‡ç§»åŠ¨ã€ç½‘ç»œæ•°æ®åŒ…åˆ°è¾¾ã€ç£ç›˜æ“ä½œå®Œæˆã€å®šæ—¶å™¨åˆ°æœŸç­‰ã€‚

 6. Define four types of kernel-mode to user-mode transfers.

å†…æ ¸æ¨¡å¼åˆ°ç”¨æˆ·æ¨¡å¼è½¬æ¢çš„å››ç§ç±»å‹ï¼š
ä»ç³»ç»Ÿè°ƒç”¨è¿”å›ï¼š å†…æ ¸å®Œæˆäº†ç”¨æˆ·ç¨‹åºè¯·æ±‚çš„æœåŠ¡ï¼Œå‡†å¤‡å°†ç»“æœè¿”å›ç»™ç”¨æˆ·ç¨‹åºï¼Œå¹¶å°†æ§åˆ¶æƒäº¤è¿˜ã€‚è¿™æ˜¯æœ€å¸¸è§çš„è½¬æ¢ä¹‹ä¸€ã€‚
ä»å¼‚å¸¸/æ•…éšœå¤„ç†è¿”å›ï¼š å†…æ ¸å¤„ç†å®Œå¼‚å¸¸ï¼ˆä¾‹å¦‚ï¼Œå¤„ç†äº†é¡µé”™è¯¯å¹¶åŠ è½½äº†æ‰€éœ€é¡µé¢ï¼‰åï¼Œé€šå¸¸ä¼šæ¢å¤ç”¨æˆ·ç¨‹åºçš„æ‰§è¡Œï¼Œä½¿å…¶ä»ä¹‹å‰ä¸­æ–­çš„åœ°æ–¹ç»§ç»­è¿è¡Œï¼ˆæˆ–è€…å¦‚æœæ— æ³•æ¢å¤ï¼Œåˆ™ç»ˆæ­¢è¯¥è¿›ç¨‹ï¼‰ã€‚
ä»ä¸­æ–­å¤„ç†è¿”å›ï¼š å†…æ ¸å¤„ç†å®Œç¡¬ä»¶ä¸­æ–­ï¼ˆä¾‹å¦‚ï¼Œå¤„ç†äº†åˆ°è¾¾çš„ç½‘ç»œåŒ…ï¼‰åï¼Œé€šå¸¸ä¼šæ¢å¤è¢«ä¸­æ–­çš„ç”¨æˆ·ç¨‹åºçš„æ‰§è¡Œï¼ˆå¯èƒ½æ˜¯ä¹‹å‰è¿è¡Œçš„è¿›ç¨‹ï¼Œä¹Ÿå¯èƒ½æ˜¯å¦ä¸€ä¸ªå‡†å¤‡è¿è¡Œçš„è¿›ç¨‹ï¼‰ã€‚
è¿›ç¨‹è°ƒåº¦/ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼š å†…æ ¸å†³å®šåœæ­¢å½“å‰æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ï¼ˆå¯èƒ½åœ¨å†…æ ¸æ€å¤„ç†å®ŒæŸä¸ªä»»åŠ¡åï¼Œæˆ–å› ä¸ºæ—¶é—´ç‰‡ç”¨å®Œï¼‰ï¼Œé€‰æ‹©å¦ä¸€ä¸ªå¤„äºå°±ç»ªæ€çš„ç”¨æˆ·è¿›ç¨‹ï¼ŒåŠ è½½å…¶çŠ¶æ€ï¼Œå¹¶å°† CPU æ§åˆ¶æƒè½¬ç§»ç»™æ–°é€‰ä¸­çš„ç”¨æˆ·è¿›ç¨‹ã€‚
å¯åŠ¨æ–°è¿›ç¨‹ï¼š å†…æ ¸å®Œæˆäº†ä¸€ä¸ªæ–°è¿›ç¨‹çš„åˆ›å»ºå’Œåˆå§‹åŒ–ï¼ˆå¦‚é€šè¿‡ fork å’Œ execï¼‰ï¼Œç„¶åå°†æ§åˆ¶æƒé¦–æ¬¡è½¬ç§»ç»™è¿™ä¸ªæ–°è¿›ç¨‹çš„ç”¨æˆ·æ€å…¥å£ç‚¹ã€‚å¯ä»¥çœ‹ä½œæ˜¯è°ƒåº¦çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µã€‚

 7. Most hardware architectures provide an instruction to return from an interrupt, such as
 iret. This instruction switches the mode of operation from kernel-mode to user-mode.
 a. Explain where in the operating system this instruction would be used.
 b. Explain what happens if an application program executes this instruction.

iret (æˆ–ç±»ä¼¼) æŒ‡ä»¤ï¼š
a. åœ¨æ“ä½œç³»ç»Ÿä¸­çš„ä½¿ç”¨ä½ç½®ï¼š è¯¥æŒ‡ä»¤ä½äºä¸­æ–­ã€å¼‚å¸¸æˆ–ç³»ç»Ÿè°ƒç”¨å¤„ç†ç¨‹åºçš„æœ«å°¾ï¼Œæ˜¯å†…æ ¸å®Œæˆå¤„ç†å¹¶å°†æ§åˆ¶æƒè¿”å›ç»™ç”¨æˆ·æ¨¡å¼ä»£ç ä¹‹å‰çš„æœ€åä¸€æ­¥ã€‚å®ƒçš„ä½œç”¨æ˜¯åŸå­åœ°æ¢å¤ä¹‹å‰ä¿å­˜çš„ç”¨æˆ·æ€çš„æŒ‡ä»¤æŒ‡é’ˆã€ä»£ç æ®µã€æ ‡å¿—å¯„å­˜å™¨ï¼Œå¹¶å°† CPU æ¨¡å¼åˆ‡æ¢å›ç”¨æˆ·æ¨¡å¼ï¼Œå¯èƒ½è¿˜ä¼šæ¢å¤ç”¨æˆ·æ€çš„æ ˆæŒ‡é’ˆã€‚
b. åº”ç”¨ç¨‹åºæ‰§è¡Œ iretï¼š iret (æˆ– sysexit, sysret ç­‰) é€šå¸¸æ˜¯ç‰¹æƒæŒ‡ä»¤ã€‚å¦‚æœç”¨æˆ·æ¨¡å¼ä¸‹çš„åº”ç”¨ç¨‹åºè¯•å›¾æ‰§è¡Œå®ƒï¼Œç¡¬ä»¶ä¼šæ£€æµ‹åˆ°æƒé™ä¸è¶³ï¼Œå¹¶è§¦å‘ä¸€ä¸ªä¿æŠ¤æ€§å¼‚å¸¸ (Protection Fault / General Protection Fault)ã€‚è¿™ä¸ªå¼‚å¸¸ä¼šå†æ¬¡å°†æ§åˆ¶æƒé™·é˜± (trap) å›å†…æ ¸ã€‚å†…æ ¸çš„å¼‚å¸¸å¤„ç†ç¨‹åºä¼šè¯†åˆ«å‡ºè¿™æ˜¯ä¸€ä¸ªéæ³•æ“ä½œï¼Œé€šå¸¸çš„å¤„ç†æ–¹å¼æ˜¯ç»ˆæ­¢è¿™ä¸ªè¯•å›¾æ‰§è¡Œéæ³•æŒ‡ä»¤çš„ç”¨æˆ·åº”ç”¨ç¨‹åºã€‚

 8. A hardware designer argues that there is now enough on-chip transistors to provide
 1024 integer registers and 512 floating point registers. As a result, the compiler should
 almost never need to store anything on the stack. As an operating system guru, give
 your opinion of this design.
 a. What is the effect on the operating system of having a large number of registers?
 b. What hardware features would you recommend adding to the design?
 c. What happens if the hardware designer also wants to add a 16-stage pipeline into
 the CPU, with precise exceptions. How would that affect the user-kernel switching
 overhead?

a. å¯¹æ“ä½œç³»ç»Ÿçš„å½±å“ï¼š
æ˜¾è‘—å¢åŠ ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ï¼š ä¸»è¦çš„è´Ÿé¢å½±å“ã€‚æ¯æ¬¡è¿›ç¨‹åˆ‡æ¢ã€ç”šè‡³æ¯æ¬¡ä¸­æ–­/å¼‚å¸¸å¤„ç†ï¼ˆå¦‚æœéœ€è¦åˆ‡æ¢åˆ°ä¸åŒè¿›ç¨‹çš„ä¸Šä¸‹æ–‡ï¼‰ï¼Œæ“ä½œç³»ç»Ÿéƒ½éœ€è¦ä¿å­˜å½“å‰è¿›ç¨‹çš„æ‰€æœ‰ 1024 ä¸ªæ•´æ•°å¯„å­˜å™¨å’Œ 512 ä¸ªæµ®ç‚¹å¯„å­˜å™¨ï¼Œå¹¶åŠ è½½ä¸‹ä¸€ä¸ªè¿›ç¨‹çš„ç›¸åº”å¯„å­˜å™¨ã€‚è¿™æ¯”ä¿å­˜/åŠ è½½ä¼ ç»Ÿçš„ 32 æˆ– 64 ä¸ªé€šç”¨å¯„å­˜å™¨è¦æ…¢å¾—å¤šï¼Œæ¶ˆè€—æ›´å¤šçš„å†…å­˜å¸¦å®½å’Œ CPU æ—¶é—´ï¼Œä»è€Œé™ä½äº†ç³»ç»Ÿçš„æ•´ä½“ååé‡å’Œå“åº”æ€§ã€‚
å¯èƒ½å‡å°‘å‡½æ•°è°ƒç”¨æ ˆçš„ä½¿ç”¨ï¼š å¯¹äºå•ä¸ªç¨‹åºæ‰§è¡Œæµå†…éƒ¨ï¼Œæ›´å¤šçš„å¯„å­˜å™¨å¯èƒ½æ„å‘³ç€ç¼–è¯‘å™¨å¯ä»¥å°†æ›´å¤šçš„å±€éƒ¨å˜é‡å’Œä¸­é—´ç»“æœä¿å­˜åœ¨å¯„å­˜å™¨ä¸­ï¼Œå‡å°‘å¯¹å†…å­˜æ ˆçš„è®¿é—®ï¼Œç†è®ºä¸Šå¯ä»¥æé«˜å•çº¿ç¨‹æ‰§è¡Œé€Ÿåº¦ã€‚ä½†è¿™å¹¶ä¸èƒ½æ¶ˆé™¤ä¸Šä¸‹æ–‡åˆ‡æ¢çš„æˆæœ¬ã€‚

9. With virtual machines, the host kernel runs in privileged mode to create a virtual
 machine that runs in user mode. The virtual machine provides the illusion that the
 guest kernel runs on its own machine in privileged mode, even though it is actually
 running in user mode.
 Early versions of the x86 architecture (pre-2006) were not completely virtualizable â€”
 these systems could not guarantee to run unmodified guest operating systems
 properly. One problem was the popf â€œpop flagsâ€ instruction that restores the processor
 status word. When popf was run in privileged mode, it changed both the ALU flags
 (e.g., the condition codes) and the systems flags (e.g., the interrupt mask). When popf
 was run in unprivileged mode, it changed just the ALU flags.
a. Why do instructions like popf prevent transparent virtualization of the (old) x86
 architecture?
 b. How would you change the (old) x86 hardware to fix this problem?

10. Which of the following components is responsible for loading the initial value in the
 program counter for an application program before it starts running: the compiler, the
 linker, the kernel, or the boot ROM?

11. We described how the operating system kernel mediates access to I/O devices for
 safety. Some newer I/O devices are virtualizable â€” they permit safe access from user
level programs, such as a guest operating system running in a virtual machine.
 Explain how you might design the hardware and software to get this to work. (Hint:
 The device needs much of the same hardware support as the operating system
 kernel.)

12. System calls vs. procedure calls: How much more expensive is a system call than a
 procedure call? Write a simple test program to compare the cost of a simple procedure
 call to a simple system call (getpid() is a good candidate on UNIX; see the man page).
 To prevent the optimizing compiler from â€œoptimizing out" your procedure calls, do not
 compile with optimization on. You should use a system call such as the UNIX
 gettimeofday() for time measurements. Design your code so the measurement
 overhead is negligible. Also, be aware that timer values in some systems have limited
 resolution (e.g., millisecond resolution).
 Explain the difference (if any) between the time required by your simple procedure call
 and simple system call by discussing what work each call must do.

13. Suppose you have to implement an operating system on hardware that supports
 interrupts and exceptions but does not have a trap instruction. Can you devise a
 satisfactory substitute for traps using interrupts and/or exceptions? If so, explain how.
 If not, explain why.

æ›¿ä»£é™·é˜±æŒ‡ä»¤ (Trap Instruction)ï¼š
å¯ä»¥ã€‚ å¯ä»¥ä½¿ç”¨å¤„ç†å™¨å¼‚å¸¸ (Processor Exception) æ¥æ¨¡æ‹Ÿé™·é˜±ã€‚
æ–¹æ³•ï¼š
æ“ä½œç³»ç»Ÿé¢„ç•™ä¸€ä¸ªç‰¹å®šçš„ã€ç”¨æˆ·ç¨‹åºå¯ä»¥æ•…æ„è§¦å‘çš„å¼‚å¸¸ã€‚å¸¸è§çš„é€‰æ‹©æ˜¯ï¼š
æ‰§è¡Œä¸€æ¡éæ³•æŒ‡ä»¤ (Undefined Instruction Exception)ã€‚OS å¯ä»¥ä¿ç•™ä¸€ä¸ªç‰¹å®šçš„ã€ä¿è¯éæ³•çš„æ“ä½œç ã€‚
æ‰§è¡Œä¸€æ¡ç‰¹æƒæŒ‡ä»¤ (Privileged Instruction Exception)ã€‚ç”¨æˆ·æ€æ‰§è¡Œç‰¹æƒæŒ‡ä»¤ä¼šè§¦å‘å¼‚å¸¸ã€‚
è®¿é—®ä¸€ä¸ªç‰¹å®šçš„ã€æ— æ•ˆçš„å†…å­˜åœ°å€ (Segmentation Fault / Page Fault)ã€‚OS å¯ä»¥ä¿ç•™ä¸€å°å—æ°¸è¿œä¸æ˜ å°„çš„å†…å­˜åŒºåŸŸï¼Œè®¿é—®å®ƒå°±ä¼šè§¦å‘å¼‚å¸¸ã€‚
ä½¿ç”¨è½¯ä»¶ä¸­æ–­æŒ‡ä»¤ (Software Interrupt / Breakpoint Instruction)ï¼Œå¦‚æœç¡¬ä»¶æ”¯æŒçš„è¯ï¼ˆä¾‹å¦‚ x86 çš„ int n æŒ‡ä»¤ï¼Œå³ä½¿æ²¡æœ‰ä¸“é—¨çš„ syscallï¼Œint æœ¬èº«ä¹Ÿå¯ä»¥ç”¨äºé™·é˜±ï¼Œè™½ç„¶å®ƒé€šå¸¸è¢«å½’ç±»ä¸ºä¸­æ–­ï¼‰ã€‚
é™¤é›¶å¼‚å¸¸ (Divide-by-zero Exception)ã€‚å¯ä»¥é€šè¿‡è®¾ç½®ç‰¹å®šçš„è¢«é™¤æ•°å’Œé™¤æ•°ï¼ˆ0ï¼‰æ¥è§¦å‘ã€‚
å½“ç”¨æˆ·ç¨‹åºéœ€è¦è¿›è¡Œâ€œç³»ç»Ÿè°ƒç”¨â€æ—¶ï¼Œå®ƒä¸æ‰§è¡Œ trap æŒ‡ä»¤ï¼Œè€Œæ˜¯æ‰§è¡Œé€‰å®šçš„ã€ä¼šè§¦å‘é¢„ç•™å¼‚å¸¸çš„æ“ä½œï¼Œå¹¶å°†ç³»ç»Ÿè°ƒç”¨å·å’Œå‚æ•°æŒ‰çº¦å®šæ”¾åœ¨å¯„å­˜å™¨æˆ–å†…å­˜ä¸­ã€‚
CPU å‘ç”Ÿå¼‚å¸¸ï¼Œæ§åˆ¶æƒè½¬ç§»åˆ°å†…æ ¸çš„å¼‚å¸¸å¤„ç†ç¨‹åºã€‚
å†…æ ¸çš„å¼‚å¸¸å¤„ç†ç¨‹åºæ£€æŸ¥å¼‚å¸¸ç±»å‹ã€‚å¦‚æœæ˜¯é¢„ç•™çš„â€œç³»ç»Ÿè°ƒç”¨â€å¼‚å¸¸ï¼Œå®ƒå°±ä»çº¦å®šçš„ä½ç½®è¯»å–ç³»ç»Ÿè°ƒç”¨å·å’Œå‚æ•°ï¼Œç„¶ååˆ†æ´¾åˆ°ç›¸åº”çš„å†…æ ¸æœåŠ¡ä¾‹ç¨‹ã€‚
å¤„ç†å®Œæˆåï¼Œå†…æ ¸é€šè¿‡ç±»ä¼¼ iret çš„æŒ‡ä»¤è¿”å›ç”¨æˆ·ç¨‹åºã€‚
å¯è¡Œæ€§ï¼š è¿™ç§æ–¹æ³•æ˜¯å¯è¡Œçš„ï¼Œæ—©æœŸç³»ç»Ÿæˆ–æŸäº›åµŒå…¥å¼ç³»ç»Ÿå¯èƒ½å°±é‡‡ç”¨ç±»ä¼¼æ–¹å¼ã€‚ä½†å®ƒå¯èƒ½æ¯”ä¸“é—¨çš„ trap æˆ– syscall æŒ‡ä»¤æ•ˆç‡ç¨ä½ï¼Œå› ä¸ºå®ƒä¾èµ–äºé€šç”¨çš„å¼‚å¸¸å¤„ç†æœºåˆ¶ã€‚

14. Suppose you have to implement an operating system on hardware that supports
 exceptions and traps but does not have interrupts. Can you devise a satisfactory
 substitute for interrupts using exceptions and/or traps? If so, explain how. If not,
 explain why.

æ›¿ä»£ä¸­æ–­ (Interrupts)ï¼š
ä¸å¯ä»¥æœ‰æ•ˆåœ°æ›¿ä»£ã€‚ ä½¿ç”¨å¼‚å¸¸å’Œé™·é˜±æ— æ³•å®Œå…¨æ›¿ä»£ç¡¬ä»¶ä¸­æ–­çš„åŠŸèƒ½ï¼Œå°¤å…¶æ˜¯åœ¨å¤„ç†å¼‚æ­¥ I/O å’Œå®ç°æŠ¢å å¼å¤šä»»åŠ¡æ–¹é¢ã€‚
åŸå› ï¼š
å¼‚æ­¥æ€§ï¼š ä¸­æ–­çš„æ ¸å¿ƒä»·å€¼åœ¨äºå¤„ç†å¼‚æ­¥äº‹ä»¶â€”â€”é‚£äº›ä¸ CPU å½“å‰æ‰§è¡Œçš„æŒ‡ä»¤æµæ— å…³çš„å¤–éƒ¨äº‹ä»¶ï¼ˆç£ç›˜å®Œæˆè¯»å†™ã€ç½‘ç»œåŒ…åˆ°è¾¾ã€å®šæ—¶å™¨åˆ°æœŸï¼‰ã€‚é™·é˜±å’Œå¼‚å¸¸éƒ½æ˜¯åŒæ­¥äº‹ä»¶ï¼Œå®ƒä»¬æ˜¯ç”± CPU å½“å‰æ­£åœ¨æ‰§è¡Œçš„æŒ‡ä»¤ç›´æ¥å¼•èµ·çš„ã€‚
I/O å¤„ç†ï¼š æ²¡æœ‰ä¸­æ–­ï¼Œæ“ä½œç³»ç»Ÿåªèƒ½ä½¿ç”¨è½®è¯¢ (Polling) æ¥æ£€æŸ¥ I/O è®¾å¤‡çš„çŠ¶æ€ã€‚CPU éœ€è¦ä¸æ–­åœ°ã€ä¸»åŠ¨åœ°å»è¯¢é—®æ¯ä¸ªè®¾å¤‡ï¼šâ€œä½ å®Œæˆäº†å—ï¼Ÿâ€ â€œæœ‰æ•°æ®å—ï¼Ÿâ€ã€‚è¿™æå¤§åœ°æµªè´¹äº† CPU æ—¶é—´ï¼Œæ•ˆç‡ä½ä¸‹ï¼Œå¹¶ä¸”å¯èƒ½å¯¼è‡´äº‹ä»¶å“åº”å»¶è¿Ÿï¼ˆå¦‚æœåœ¨è½®è¯¢å…¶ä»–è®¾å¤‡æ—¶é”™è¿‡äº†æŸä¸ªè®¾å¤‡çš„ä¿¡å·ï¼‰ã€‚
æŠ¢å å¼å¤šä»»åŠ¡ï¼š å®šæ—¶å™¨ä¸­æ–­æ˜¯å®ç°æŠ¢å å¼å¤šä»»åŠ¡çš„åŸºç¡€ã€‚å†…æ ¸ä¾èµ–å®šæ—¶å™¨ä¸­æ–­æ¥å‘¨æœŸæ€§åœ°è·å¾— CPU æ§åˆ¶æƒï¼Œå³ä½¿å½“å‰è¿è¡Œçš„ç”¨æˆ·ç¨‹åºä¸æ„¿æ„æ”¾å¼ƒ CPUï¼ˆä¾‹å¦‚é™·å…¥æ­»å¾ªç¯ï¼‰ã€‚æ²¡æœ‰å®šæ—¶å™¨ä¸­æ–­ï¼Œç³»ç»Ÿåªèƒ½å®ç°åä½œå¼å¤šä»»åŠ¡ï¼ˆç¨‹åºå¿…é¡»è‡ªæ„¿è°ƒç”¨ yield ä¹‹ç±»çš„å‡½æ•°æ”¾å¼ƒ CPUï¼‰ï¼Œæˆ–è€…åœ¨å•ä¸ªç¨‹åºå¡æ­»æ—¶æ•´ä¸ªç³»ç»Ÿå¤±å»å“åº”ã€‚
ç»“è®ºï¼š é™·é˜±å’Œå¼‚å¸¸å¤„ç† CPU å†…éƒ¨æˆ–ç¨‹åºæ‰§è¡Œå¼•å‘çš„äº‹ä»¶ï¼Œè€Œä¸­æ–­å¤„ç†å¤–éƒ¨ç¡¬ä»¶å¼•å‘çš„å¼‚æ­¥äº‹ä»¶ã€‚ä¸¤è€…æœºåˆ¶ä¸åŒï¼Œç›®çš„ä¸åŒï¼Œæ— æ³•äº’ç›¸å®Œå…¨æ›¿ä»£ã€‚æ²¡æœ‰ä¸­æ–­çš„ç³»ç»Ÿå°†éå¸¸ä½æ•ˆä¸”å“åº”æ€§å·®ã€‚

15. Explain the steps that an operating system goes through when the CPU receives an
 interrupt.

16. When an operating system receives a system call from a program, a switch to
 operating system code occurs with the help of the hardware. The hardware sets the
 mode of operation to kernel mode, calls the operating system trap handler at a
 location specified by the operating system, and lets the operating system return to
 user mode after it finishes its trap handling.
 Consider the stack on which the operating system must run when it receives the
 system call. Should this stack be different from the one the application uses, or could it
use the same stack as the application program? Assume that the application program
 is blocked while the system call runs.

17. Write a program to verify that the operating system on your computer correctly
 protects itself from rogue system calls. For a single system call â€” such as file system
 open â€” try all possible illegal calls: e.g., an invalid system call number, an invalid
 stack pointer, an invalid pointer stored on the stack, etc. What happens





